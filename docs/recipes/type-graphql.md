---
id: type-graphql
title: TypeGraphQL Integration
sidebar_label: TypeGraphQL
---

**TypeGraphQL** is a set of tools that provides you some decorators, and you can use these decorators to define your parts of schema. So, you can define all your type definitions and resolvers using **TypeScript** classes thanks to **TypeGraphQL** decorators. **[You can check out TypeGraphQL docs to learn more.](https://typegraphql.ml/)**

- GraphQL Modules provides encapsulated Dependency Injection which allows you to seperate your logic from resolvers. Easy for testing, because you can mock providers and stuff in DI.
Schema is encapsulated so in that case, you can have standalone modules that is written in code-first. 

- GraphQL Modules provides encapsulated Dependency Injection which allows you to seperate your logic from resolvers. Easy for testing, because you can mock providers and stuff in DI.
Schema is encapsulated so in that case, you can have standalone modules that is written in code-first. 

You can import the schema that is generated by TypeGraphQL in your GraphQL Module.

Let's assume we have Chat type for base fields that is shared with entity.

`chat.type.ts`

```ts
import { ObjectType, Field, ID } from 'type-graphql';

@ObjectType()
export class Chat {
  
  @Field(type => ID)
  id: number;

  @Field()
  title: string;

  @Field({ nullable: true })
  description?: string;

}
```

Create another class for our queries and mutations based on this type;

`chat.resolver.ts`

```ts
import { ChatsProvider } from "./chats.provider";
import { Resolver, Mutation, Arg, Int, Query } from 'type-graphql';
import { Chat } from "./chat.type";

@Resolver(of => Chat)
export class ChatResolver {
  constructor(private chatsProvider: ChatsProvider){}

  @Query(returns => [Chat])
  chats() {
    return this.chatsProvider.getChats();
  }
  
  @Query(returns => Chat)
  chat(@Arg('id') id: number) {
    return this.chatsProvider.getChat(id);
  }

  @Mutation(returns => Chat)
  createChat(@Arg('title') title: string, @Arg('description') description: string) {
    return this.chatsProvider.createChat({ id: Math.random(), title, description });
  }

  @Mutation(returns => Int)
  deleteChat(@Arg('id') id: number) {
    return this.chatsProvider.deleteChat(id);
  }

}
```

> You can notice that we can use GraphQL Modules Dependency Injection in TypeGraphQL. Resolvers and Providers are part of GraphQL Modules Dependency Injection in that case.

Then let's create our module;

`chat.module.ts`

```ts
import { GraphQLModule } from '@graphql-modules/core';
import { ChatsProvider } from "./chats.provider";
import { buildSchemaSync } from 'type-graphql';
import { ChatResolver } from './chat.resolver';
import { Chat } from './chat.type';

const resolvers = [
  ChatResolver
];

export const ChatsModule = new GraphQLModule({
  providers: [
    ChatsProvider,
    ...resolvers
  ],
  extraSchemas: [
    buildSchemaSync({
      resolvers,
      container: ({ context }) => context.injector
    })
  ]
});
```

We have to define resolver classes as providers because they are also part of our Dependency Injection. 
`container: ({ context }) => ChatsModule.injector.getSessionInjector(context)` tells TypeGraphQL to use `ChatsModule` DI container for those resolvers.

## Integration with other implementations

You can merge different modules from different implementations like below. So you don't have to use same implementation method in all modules. GraphQL-Modules will handle schema merging for you, even if they're from different implementations.

```ts
new GraphQLModule({
   imports: [
        XModuleCreatedUsingSchemaFirst,
        YModuleCreatedUsingNexus,
        ZModuleCreatedUsingTypeGraphQL
   ]
})
```
